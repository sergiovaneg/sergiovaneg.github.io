---
title: "Python & Go: The Benefits of being Pedantic"
date: 2024-05-15
categories: Go, Python, Rant
---

I really love opinionated tools. I am the kind of person that thrives on well-thought-out defaults: OpenSuse Gnome with minimal extensions for my Linux box, Debian on WSL (I refuse to deal with Snaps) for my Windows machine, and VSCode with official extensions only. For every piece of Software in my arsenal, I try to keep my experience as close to the developer's vision as I can. This ensures my workflow aligns with intended use cases, and any missing features or bugs I might encounter are likely to be a priority for the development team.

Developers being opinionated about their software is, in most cases, a net-positive, especially when it comes to programming-language design. While there's no single *best* solution in software, with every approach lying on a spectrum of trade-offs (or as [CodeAesthetic](https://www.youtube.com/@CodeAesthetic) brilliantly explains, a [*Triangle*](https://youtu.be/tKbV6BpH-C8?si=kxM9dwkI5zzXeYNC)), guidelines for expressing solutions are crucial. When carefully designed and put in place, code best-practices can be enforced, and transparent compiler optimization can be expected. On the other hand, when neglected, this void is either filled in consensus by the community or it becomes a painful source of duplicated efforts.

Strong opinions are often an asset for developers, particularly in shaping programming languages. Software rarely boasts a single "best" solution, as every approach lies on a spectrum of trade-offs (think of the Programmer's [*Triangle*](https://youtu.be/tKbV6BpH-C8?si=kxM9dwkI5zzXeYNC), as expertly put by [CodeAesthetic](https://www.youtube.com/@CodeAesthetic)). However, clear guidelines for expressing solutions are essential. Well-designed and implemented best practices promote consistent coding and predictable compiler optimizations; conversely, a lack of such guidance forces the community to either cobble together consensus or endure the pain of duplicated efforts.

I'm sure there are many languages that, to a lesser or greater extent, 

While my professional experience revolves around Machine Learning, primarily using Python with occasional forays into Julia and Matlab, my academic background lies in Embedded and Scientific Programming. My degrees in Electronics and Mathematical Engineering equipped me with a strong foundation in the C family of languages. I've delved into various abstraction levels, from registry manipulation with bit-masks for specific models of the AVR $\mu$-controller family to crafting complex generic classes for handling multiple numerical solvers in PDE libraries.

Despite its ever-presence in my career, I have never fancied programming in C or C++ as much as I enjoy working with Python. I can live with the lack of memory safety (although it's really nice to have), and the compilation process is really satisfactory to watch (gcc go Brrr). However, it's the lack of language consistency that truly irks me every time I revisit the C family. Every new project seems to introduce its own set of coding conventions and libraries, creating a constant learning curve that disrupts my flow.

With C, every decently-sized project is a compilation of convoluted macro hacks and deeply-nested pointers, the documentation of which should not be expected. It's like spelunking through a codebase built in the dark ages of programming, hoping not to disturb any ancient bugs. C++, on the other hand, offers an overindulgent array of options: the standard library's 4-5 ways to perform the same operation, introduced throughout the multiple releases of the spec with different *best practices* in mind depending on the current consensus, turns every sufficiently long-lived codebase into a family tree of programming paradigms. It's fascinating for historical context, but a nightmare for maintenance. And to top it all off, to this day both C and C++ lack standardized package management. This might have been acceptable back in the day, but for modern development, juggling dependencies manually while waiting for the next linking error feels just...wrong.

In this regard, Python does an amazing job with its *Pythonic* concept, which can mostly be reduced to the philosophical and practical guidelines in the [*Zen of Python*](https://peps.python.org/pep-0020/) and the [Style Guide for Python Code](https://peps.python.org/pep-0008/), respectively. Sure, similar rules can be created on a [per-team basis](https://google.github.io/styleguide/cppguide.html), but this is just an unreasonable duplication of efforts for a task that can be best done by (or at least with the seal of approval from) the people defining the spec. This is why Python has been so successful in the academic community, where Software needs to be easily peer-reviewed with a consistent set of expectations and best-practices.
